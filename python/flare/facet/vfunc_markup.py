import re
import pprint

from PySide import QtGui
from PySide import QtCore 

import idc
import idaapi
import idautils

import jayutils
from vfunc_markup_ui import Ui_Dialog

#TODO: add prefix to nail down false positives
g_addreRegExp = re.compile(r'(0x[\dA-Fa-f]{8,16})')
g_vfuncChooseCols = [ ('StructId', 80), ('Struct', 100), ('Member', 100), ('Address', 80), ('Name', 100) ]

def getPossibleStruct(stroff, regexp = g_addreRegExp):
    '''
    Returns a list of (struct_id, struct_name, field_name, address, addrname) tuples
    for structs that have a member at offset <stroff> that has a comment
    containing <regexp>.
    '''
    ret = []
    strucidx = idc.GetFirstStrucIdx()
    while strucidx != idc.BADADDR:
        sid = idc.GetStrucId(strucidx)
        memcom = idc.GetMemberComment(sid, stroff, True)
        if memcom is not None:
            m1 = regexp.search(memcom)
            if m1 is not None:
                commea = m1.group(1)
                strucname = idc.GetStrucName(sid)
                memname = idc.GetMemberName(sid, stroff)
                addrname = idc.Name(int(commea, 0))
                item = (sid, strucname, memname, commea, addrname)
                ret.append(item)
                #print 'Found (0x%x, %s, %s, %s, %s)' % (sid, strucname, memname, commea, addrname)
        strucidx = idc.GetNextStrucIdx(strucidx)
    return ret

def getVtblDerefs(ea):
    mnem = idc.GetMnem(ea)
    vtbloff = None
    #TODO: other types of vtbl data accesses?
    if mnem.startswith('call'):
        #  call [<reg> + offset]
        if idc.GetOpType(ea, 0) == idc.o_displ:
            vtbloff = idc.GetOperandValue(ea, 0)
        elif idc.GetOpType(ea, 0) == idc.o_phrase:
            #o_phrase: no immediate values -> hoping always 0 for this
            vtbloff = 0
        else:
            print 'call: Not at o_displ call'
    elif mnem.startswith('mov'):
        #  mov <targ>, [<reg> + offset]
        if idc.GetOpType(ea, 1) == idc.o_displ:
            vtbloff = idc.GetOperandValue(ea, 1)
        elif idc.GetOpType(ea, 1) == idc.o_phrase:
            #o_phrase: no immediate values -> hoping always 0 for this
            vtbloff = 0
        else:
            print 'mov: Not at o_displ mov'
    if vtbloff is None:
        return []
    return getPossibleStruct(vtbloff)

def getSourceRef(ea):
    '''
    In case the script is called at a mov instruction to load the vtbl offset,
    search forward for the next call
    '''
    count = 0
    while count < 10:
        mnem = idc.GetMnem(ea)
        if mnem.startswith('call'):
            print 'Founce sourceRef: %x' % ea
            return ea
        count += 1
        ea = idc.NextHead(ea)
    raise RuntimeError('Could not find source call ref')

class VfuncMarkupRunner(object):
    def __init__(self):
        self.logger = jayutils.getLogger('facet.VfuncMarkup')

    def run(self):
        try:
            ea = idc.here()
            srcxref = getSourceRef(ea)
            items = getVtblDerefs(ea)
            dlg = VfuncMarkupDialog(ea, items)
            oldTo = idaapi.set_script_timeout(0)
            res = dlg.exec_()
            idaapi.set_script_timeout(oldTo)
            if res == QtGui.QDialog.Accepted:
                selected = dlg.getSelected()
                self.logger.debug('Accepted!\n%s', pprint.pformat(selected))
                self.handleSelected(srcxref, selected)
            else:
                self.logger.debug('Rejected!')
            pass
        except Exception, err:
            self.logger.exception("Exception caught: %s", str(err))

    def handleSelected(self, ea, selected):
        self.clearCurrentCodeRefs(ea)
        comments = ['', 'autogenerated code xrefs:',]
        for (sid, strucname, memname, commea, addrname) in selected:
            idc.AddCodeXref(ea, commea, idc.fl_CN)
            comments.append('0x%08x: %s.%s (%s)' % (commea, strucname, memname, addrname))
        comment = str('\n    '.join(comments))
        self.logger.debug('Trying to make comment: 0x%08x: %s', ea, pprint.pformat(comment))
        idc.MakeComm(ea, comment)

    def clearCurrentCodeRefs(self, ea):
        #clear all of the current code refs from ea (ignoring normal flows)
        refs = [ref for ref in idautils.CodeRefsFrom(ea, False)]
        for ref in refs: 
            self.logger.info('Deleting existing code xref 0x%08x -> 0x%08x', ea, ref)
            idc.DelCodeXref(ea, ref, False)

class VfuncMarkupDialog(QtGui.QDialog):
    def __init__(self, ea, items, parent=None):
        QtGui.QDialog.__init__(self, parent)
        try:
            self.logger = jayutils.getLogger('facet.VfuncMarkup')
            self.logger.debug('Hello debug')
            self.ea = ea
            self.items = items
            self.ui=Ui_Dialog()
            self.ui.setupUi(self)
            self.ui.treeWidget.setColumnCount(5)
            self.ui.treeWidget.insertTopLevelItems(0, self.xformItems(items))
            labels = [item[0] for item in g_vfuncChooseCols]
            self.ui.treeWidget.setHeaderLabels(labels)
            for i, (label, width) in enumerate(g_vfuncChooseCols):
                self.ui.treeWidget.setColumnWidth(i, width)
        except Exception, err:
            self.logger.exception('Error during init: %s', str(err))

    def xformItems(self, items):
        #using simple default model, so manually translate ints to strings where appropriate
        return [ QtGui.QTreeWidgetItem( ['0x%08x' % item[0], item[1], item[2], item[3], item[4]]) for item in items]

    def getSelected(self):
        #using simple default model, so manually translate strings to ints where appropriate
        data = [[ item.text(col) for col in range(item.columnCount())] for item in self.ui.treeWidget.selectedItems()]
        for item in data:
            item[0] = int(item[0], 0)
            item[3] = int(item[3], 0)
        return data

#def main():
#    #logger = jayutils.configLogger('', logging.DEBUG)
#    logger = jayutils.configLogger('', logging.INFO)
#    launcher = VfuncMarkupRunner()
#    launcher.run()
#
#if __name__ == '__main__':
#    main()
